# Main.cpp - Application Entry Point Documentation

## Overview

The `main.cpp` file serves as the entry point for the NetworkSniffer application. It implements a command-line interface for network packet capture using Berkeley Packet Filter (BPF) on macOS systems. This file orchestrates the entire application lifecycle from argument validation to graceful shutdown.

## Architecture and Design

### Application Flow
1. **Command-line validation** - Ensures proper arguments are provided
2. **Signal handler setup** - Enables graceful shutdown via Ctrl+C
3. **Sniffer initialization** - Creates and configures the packet capture system
4. **Main execution loop** - Runs packet capture until interrupted
5. **Error handling** - Provides meaningful feedback to users

### Design Principles
- **Simplicity**: Clear, linear execution flow
- **Robustness**: Comprehensive error handling and validation
- **User-friendly**: Helpful usage messages and clear error reporting
- **Educational**: Extensive comments explaining each step

## Dependencies and Headers

```cpp
#include "Sniffer.h"   // Main packet capture and BPF management class
#include <iostream>    // Standard I/O for user interaction
#include <csignal>     // POSIX signal handling (SIGINT, SIGTERM)
#include <cstdlib>     // Standard library utilities (exit)
```

### Why These Dependencies?
- **Sniffer.h**: Provides the core packet capture functionality through BPF
- **iostream**: Required for user communication (cout, cerr)
- **csignal**: Enables clean shutdown when user presses Ctrl+C
- **cstdlib**: Provides exit() function for immediate termination

## Signal Handling Implementation

### Global State Management
```cpp
static bool running = true;
```

**Purpose**: This global flag controls the application's main loop. It's set to `false` when a termination signal is received.

**Why static?**: The `static` keyword limits visibility to this compilation unit, preventing external code from accidentally modifying the flag.

### Signal Handler Function
```cpp
void signalHandler(int signum) {
    std::cout << "\nReceived signal " << signum << ", stopping..." << std::endl;
    running = false;
    exit(0);
}
```

**How it works**:
1. **Signal reception**: When SIGINT (Ctrl+C) or SIGTERM is received, this function is called
2. **User notification**: Informs the user that shutdown is beginning
3. **Flag setting**: Sets `running = false` (though not used in current implementation)
4. **Immediate exit**: Calls `exit(0)` to terminate immediately

**Signal Types Handled**:
- **SIGINT (2)**: Generated by Ctrl+C - most common user-initiated shutdown
- **SIGTERM (15)**: System shutdown request - allows clean termination during system shutdown

**Signal Safety Considerations**:
- `std::cout` is technically not async-signal-safe, but works in practice
- For production code, consider using `write()` system call instead
- The handler keeps functionality minimal to reduce signal safety risks

## Command-Line Interface

### Usage Validation
```cpp
if (argc != 2) {
    printUsage(argv[0]);
    return 1;
}
```

**Requirements**: The program expects exactly one argument - the network interface name.
- `argc = 1`: Program name only (no arguments) - invalid
- `argc = 2`: Program name + interface name - valid
- `argc > 2`: Too many arguments - invalid

### Usage Information Display
```cpp
void printUsage(const char* program_name) {
    std::cout << "Usage: " << program_name << " <interface>" << std::endl;
    std::cout << "Example: " << program_name << " en0" << std::endl;
    std::cout << "Note: Requires root privileges (run with sudo)" << std::endl;
}
```

**Purpose**: Provides helpful guidance when users run the program incorrectly.

**Information Provided**:
- **Syntax**: Shows correct command format
- **Example**: Demonstrates usage with common interface name "en0"
- **Privilege warning**: Reminds users that root access is required

**Common Interface Names on macOS**:
- `en0`: Primary Ethernet interface
- `en1`: Secondary Ethernet or USB-to-Ethernet adapter
- `awdl0`: Apple Wireless Direct Link (AirDrop)
- `lo0`: Loopback interface (for testing)

## Main Function Breakdown

### Signal Handler Registration
```cpp
signal(SIGINT, signalHandler);   // Handle Ctrl+C (interrupt)
signal(SIGTERM, signalHandler);  // Handle termination requests
```

**Why these signals?**
- **SIGINT**: User-initiated interruption (Ctrl+C) - most common case
- **SIGTERM**: System-requested termination - allows graceful shutdown during system reboot

**Registration timing**: Done early in main() to ensure handlers are active before any long-running operations begin.

### Interface Name Extraction
```cpp
std::string interface = argv[1];
```

**Simple assignment**: Converts C-style string to C++ string for easier manipulation and memory management.

**Validation**: Interface name validity is checked later by the Sniffer constructor when it attempts to bind to the interface.

### Exception-Safe Resource Management
```cpp
try {
    Sniffer sniffer(interface);
    sniffer.run();
} catch (const std::exception& e) {
    std::cerr << "Error: " << e.what() << std::endl;
    return 1;
}
```

**RAII Pattern**: The Sniffer object automatically manages BPF device resources:
- **Constructor**: Opens BPF device, configures interface, allocates buffers
- **Destructor**: Automatically closes BPF device when object goes out of scope

**Exception Handling**: Catches any errors during initialization or runtime:
- **std::exception**: Base class catches all standard exceptions
- **Error display**: Shows meaningful error messages to users
- **Return code**: Returns 1 to indicate failure to the shell

## Common Errors and Solutions

### "No BPF devices available"
**Cause**: All BPF devices (/dev/bpf0 through /dev/bpf99) are in use
**Solution**: 
- Close other network monitoring tools
- Reboot system to reset BPF device states
- Check that no other instances of the sniffer are running

### "Failed to bind to interface"
**Cause**: Invalid interface name or interface doesn't exist
**Solution**:
- Use `ifconfig` to list available interfaces
- Check spelling of interface name
- Ensure interface is up and configured

### "Permission denied"
**Cause**: Attempting to access BPF devices without root privileges
**Solution**: Run with `sudo ./NetworkSniffer en0`

### "Interface not found"
**Cause**: Specified interface doesn't exist on the system
**Solution**: Use `networksetup -listallhardwareports` (macOS) to see available interfaces

## System Requirements

### Operating System
- **macOS**: Primary target platform (uses native BPF support)
- **Linux**: Would require modifications to use libpcap instead

### Privileges
- **Root access required**: BPF devices are restricted to root user
- **Why root?**: Packet capture can potentially access sensitive network traffic

### Network Interface
- **Interface must exist**: System must have the specified network interface
- **Interface should be active**: While not strictly required, active interfaces produce more interesting results

## Educational Value

### Learning Objectives
This code demonstrates several important concepts:

1. **System Programming**: Interaction with kernel network subsystems
2. **Signal Handling**: Proper cleanup when programs are interrupted
3. **Error Handling**: Exception-safe programming practices
4. **Resource Management**: RAII pattern for automatic cleanup
5. **User Interface Design**: Clear, helpful command-line interfaces

### Best Practices Demonstrated
- **Defensive programming**: Validate all inputs before use
- **Clear error messages**: Help users understand what went wrong
- **Resource cleanup**: Ensure system resources are properly released
- **Documentation**: Comprehensive comments explaining design decisions

## Future Enhancements

### Potential Improvements
1. **Configuration files**: Allow saving frequently-used options
2. **Multiple interfaces**: Support monitoring multiple interfaces simultaneously  
3. **Filtering options**: Add BPF filter expressions for selective capture
4. **Output formats**: Support JSON, XML, or other structured output
5. **Daemonization**: Run as background service
6. **Log rotation**: Automatic log file management for long-running captures

### Advanced Features
1. **Real-time statistics**: Show packet counts, bandwidth usage
2. **Protocol-specific modes**: Focus on specific protocols (HTTP, DNS, etc.)
3. **Alerting**: Notify on suspicious traffic patterns
4. **Integration**: Export data to external monitoring systems

## Security Considerations

### Privilege Requirements
- **Root access**: Required for BPF device access
- **Security implications**: Can capture sensitive network traffic
- **Best practice**: Run only when needed, with minimal privileges

### Data Handling
- **Sensitive information**: Captured packets may contain passwords, personal data
- **Storage considerations**: Be careful about logging captured data
- **Privacy**: Ensure compliance with applicable privacy laws

This documentation provides a comprehensive understanding of how the main.cpp file orchestrates the NetworkSniffer application, from startup to shutdown, with emphasis on proper error handling, user experience, and system resource management.